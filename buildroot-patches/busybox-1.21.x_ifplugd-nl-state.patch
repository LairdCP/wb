diff -Naur busybox-1.21.x/networking/ifplugd.c busybox-1.21.x/networking/ifplugd.c
--- busybox-1.21.x/networking/ifplugd.c	2014-01-08 11:15:27.084257071 -0600
+++ busybox-1.21.x/networking/ifplugd.c	2014-01-08 11:15:27.084257071 -0600
@@ -54,16 +54,6 @@
 functional style. The main role is run a script when link state
 changed, other activities like audio signal or detailed reports
 are on the script itself.
-
-One questionable point of the design is netlink usage:
-
-We have 1 second timeout by default to poll the link status,
-it is short enough so that there are no real benefits in
-using netlink to get "instantaneous" interface creation/deletion
-notifications. We can check for interface existence by just
-doing some fast ioctl using its name.
-
-Netlink code then can be just dropped (1k or more?)
 */
 
 
@@ -100,8 +90,10 @@
 
 enum { // interface status
 	IFSTATUS_ERR = -1,
-	IFSTATUS_DOWN = 0,
-	IFSTATUS_UP = 1,
+	IFSTATUS_DOWN,
+	IFSTATUS_DORMANT,
+	IFSTATUS_UP,
+	IFSTATUS_UPAGAIN,
 };
 
 enum { // constant fds
@@ -154,6 +146,7 @@
 	return r;
 }
 
+
 /* Link detection routines and table */
 
 static smallint detect_link_mii(void)
@@ -290,12 +283,33 @@
 };
 
 
+static int operstate(int state)
+{
+	static int state_x = IFSTATUS_DORMANT;
+
+	/* Translate RFC2863 ifla_operstate to ifstatus value. */
+
+	if (state == IF_OPER_UP)
+		state = ( state_x == IFSTATUS_UP ? IFSTATUS_UPAGAIN : IFSTATUS_UP );
+	else
+	if (state == IF_OPER_DORMANT)
+		state = IFSTATUS_DORMANT;
+	else
+	if (state == IF_OPER_LOWERLAYERDOWN
+	||  state == IF_OPER_DOWN)
+		state = IFSTATUS_DOWN;
+	else
+		state = IFSTATUS_ERR;
+
+	state_x = state;
+
+   return state;
+}
 
 static const char *strstatus(int status)
 {
-	if (status == IFSTATUS_ERR)
-		return "error";
-	return "down\0up" + (status * 5);
+	return "error\0\0\0down\0\0\0\0dormant\0up\0\0\0\0\0\0up\ again"
+	       + (status*8) +8;
 }
 
 static int run_script(const char *action)
@@ -329,13 +343,19 @@
 	return (option_mask32 & FLAG_IGNORE_RETVAL) ? 0 : r;
 }
 
-static void up_iface(void)
+static void maybe_up_iface(void)
 {
 	struct ifreq ifrequest;
 
 	if (!G.iface_exists)
 		return;
 
+	if (option_mask32 & FLAG_NO_AUTO)
+		return;
+
+	if (G.api_mode[0] == 'a')
+		G.api_method_num = API_AUTO;
+
 	set_ifreq_to_ifname(&ifrequest);
 	if (network_ioctl(SIOCGIFFLAGS, &ifrequest, "getting interface flags") < 0) {
 		G.iface_exists = 0;
@@ -349,53 +369,6 @@
 		if (network_ioctl(SIOCSIFFLAGS, &ifrequest, "setting interface flags") < 0)
 			xfunc_die();
 	}
-
-#if 0 /* why do we mess with IP addr? It's not our business */
-	if (network_ioctl(SIOCGIFADDR, &ifrequest, "can't get interface address") < 0) {
-	} else if (ifrequest.ifr_addr.sa_family != AF_INET) {
-		bb_perror_msg("the interface is not IP-based");
-	} else {
-		((struct sockaddr_in*)(&ifrequest.ifr_addr))->sin_addr.s_addr = INADDR_ANY;
-		network_ioctl(SIOCSIFADDR, &ifrequest, "can't set interface address");
-	}
-	network_ioctl(SIOCGIFFLAGS, &ifrequest, "can't get interface flags");
-#endif
-}
-
-static void maybe_up_new_iface(void)
-{
-	if (!(option_mask32 & FLAG_NO_AUTO))
-		up_iface();
-
-#if 0 /* bloat */
-	struct ifreq ifrequest;
-	struct ethtool_drvinfo driver_info;
-
-	set_ifreq_to_ifname(&ifrequest);
-	driver_info.cmd = ETHTOOL_GDRVINFO;
-	ifrequest.ifr_data = &driver_info;
-	if (network_ioctl(SIOCETHTOOL, &ifrequest, NULL) == 0) {
-		char buf[sizeof("/xx:xx:xx:xx:xx:xx")];
-
-		/* Get MAC */
-		buf[0] = '\0';
-		set_ifreq_to_ifname(&ifrequest);
-		if (network_ioctl(SIOCGIFHWADDR, &ifrequest, NULL) == 0) {
-			sprintf(buf, "/%02X:%02X:%02X:%02X:%02X:%02X",
-				(uint8_t)(ifrequest.ifr_hwaddr.sa_data[0]),
-				(uint8_t)(ifrequest.ifr_hwaddr.sa_data[1]),
-				(uint8_t)(ifrequest.ifr_hwaddr.sa_data[2]),
-				(uint8_t)(ifrequest.ifr_hwaddr.sa_data[3]),
-				(uint8_t)(ifrequest.ifr_hwaddr.sa_data[4]),
-				(uint8_t)(ifrequest.ifr_hwaddr.sa_data[5]));
-		}
-
-		bb_error_msg("using interface %s%s with driver<%s> (version: %s)",
-			G.iface, buf, driver_info.driver, driver_info.version);
-	}
-#endif
-	if (G.api_mode[0] == 'a')
-		G.api_method_num = API_AUTO;
 }
 
 static smallint detect_link(void)
@@ -403,14 +376,13 @@
 	smallint status;
 
 	if (!G.iface_exists)
-		return (option_mask32 & FLAG_MONITOR) ? IFSTATUS_DOWN : IFSTATUS_ERR;
+		return IFSTATUS_ERR;
 
 	/* Some drivers can't detect link status when the interface is down.
 	 * I imagine detect_link_iff() is the most vulnerable.
 	 * That's why -a "noauto" in an option, not a hardwired behavior.
 	 */
-	if (!(option_mask32 & FLAG_NO_AUTO))
-		up_iface();
+	maybe_up_iface();
 
 	if (G.api_method_num == API_AUTO) {
 		int i;
@@ -427,16 +399,19 @@
 				break;
 			}
 		}
-	} else {
+	}
+	else {
 		status = method_table[G.api_method_num].func();
 	}
 
 	if (status == IFSTATUS_ERR) {
 		if (option_mask32 & FLAG_IGNORE_FAIL)
 			status = IFSTATUS_DOWN;
-		else if (option_mask32 & FLAG_IGNORE_FAIL_POSITIVE)
+		else
+		if (option_mask32 & FLAG_IGNORE_FAIL_POSITIVE)
 			status = IFSTATUS_UP;
-		else if (G.api_mode[0] == 'a')
+		else
+		if (G.api_mode[0] == 'a')
 			bb_error_msg("can't detect link status");
 	}
 
@@ -448,9 +423,8 @@
 	return status;
 }
 
-static NOINLINE int check_existence_through_netlink(void)
+static NOINLINE int check_netlink(int *status)
 {
-	int iface_len;
 	/*
 	 * Messages in/aft linux-3.8 can exceed 1K buffer size, so increased to 8K.
 	 * netlink.h: "limit to 8K to avoid MSG_TRUNC when PAGE_SIZE is very large".
@@ -461,7 +435,6 @@
 	enum { BUF_SIZE = 8 * 1024 };
 	char *replybuf = xmalloc(BUF_SIZE);
 
-	iface_len = strlen(G.iface);
 	while (1) {
 		struct nlmsghdr *mhdr;
 		ssize_t bytes;
@@ -480,16 +453,17 @@
 		mhdr = (struct nlmsghdr*)replybuf;
 		while (bytes > 0) {
 			if (!NLMSG_OK(mhdr, bytes)) {
-				bb_error_msg("netlink packet too small or truncated");
+				bb_error_msg("!NLMSG_OK: packet too small or truncated");
 				return -1;
 			}
 
-			if (mhdr->nlmsg_type == RTM_NEWLINK || mhdr->nlmsg_type == RTM_DELLINK) {
+			if (mhdr->nlmsg_type == RTM_NEWLINK
+			||  mhdr->nlmsg_type == RTM_DELLINK) {
 				struct rtattr *attr;
 				int attr_len;
 
 				if (mhdr->nlmsg_len < NLMSG_LENGTH(sizeof(struct ifinfomsg))) {
-					bb_error_msg("netlink packet too small or truncated");
+					bb_error_msg("NLMSG_LENGTH: packet too small or truncated");
 					return -1;
 				}
 
@@ -497,16 +471,28 @@
 				attr_len = IFLA_PAYLOAD(mhdr);
 
 				while (RTA_OK(attr, attr_len)) {
+
+					/* check matching interface name */
 					if (attr->rta_type == IFLA_IFNAME) {
 						int len = RTA_PAYLOAD(attr);
+
 						if (len > IFNAMSIZ)
 							len = IFNAMSIZ;
-						if (iface_len <= len
-						 && strncmp(G.iface, RTA_DATA(attr), len) == 0
-						) {
-							G.iface_exists = (mhdr->nlmsg_type == RTM_NEWLINK);
+
+						if (strlen(G.iface) <= len
+						&&  strncmp(G.iface, RTA_DATA(attr), len) == 0
+						   ) {
+						   G.iface_exists = (mhdr->nlmsg_type == RTM_NEWLINK);
 						}
+						else
+							break;
+					}
+
+					/* check current interface operstate */
+					if (attr->rta_type == IFLA_OPERSTATE) {
+						*status = operstate(*((unsigned char *)RTA_DATA(attr)));
 					}
+
 					attr = RTA_NEXT(attr, attr_len);
 				}
 			}
@@ -517,7 +503,7 @@
 
  ret:
 	free(replybuf);
-	return G.iface_exists;
+	return 0;
 }
 
 #if ENABLE_FEATURE_PIDFILE
@@ -620,18 +606,18 @@
 		G.iface_exists = (network_ioctl(SIOCGIFINDEX, &ifrequest, NULL) == 0);
 	}
 
-	if (G.iface_exists)
-		maybe_up_new_iface();
-
 	iface_status = detect_link();
-	if (iface_status == IFSTATUS_ERR)
-		goto exiting;
+	if (iface_status == IFSTATUS_ERR) {
+		if (opts & FLAG_MONITOR)
+			iface_status = IFSTATUS_DOWN;
+		else
+			goto exiting;
+	}
 	iface_status_str = strstatus(iface_status);
 
 	if (opts & FLAG_MONITOR) {
 		bb_error_msg("interface %s",
-			G.iface_exists ? "exists"
-			: "doesn't exist, waiting");
+		  G.iface_exists ? "exists" : "doesn't exist, waiting");
 	}
 	/* else we assume it always exists, but don't mislead user
 	 * by potentially lying that it really exists */
@@ -677,6 +663,7 @@
 		) {
 			if (errno == EINTR)
 				continue;
+
 			bb_perror_msg("poll");
 			goto exiting;
 		}
@@ -684,17 +671,24 @@
 		iface_status_old = iface_status;
 		iface_exists_old = G.iface_exists;
 
+		/* The ifstatus will be updated upon netlink event, or by an
+		 * ioctl call due to poll timeout. The ioctl method can only
+		 * detect the link state as up or down. Thus, netlink events
+		 * may be masked if option delay_up/down is not zero.
+		 */
 		if ((opts & FLAG_MONITOR)
-		 && (netlink_pollfd[0].revents & POLLIN)
-		) {
-			G.iface_exists = check_existence_through_netlink();
-			if (G.iface_exists < 0) /* error */
+		    && (netlink_pollfd[0].revents & POLLIN)) {
+
+			/* exit on a netlink message error */
+			if (check_netlink(&iface_status) < 0)
 				goto exiting;
+
 			if (iface_exists_old != G.iface_exists) {
 				bb_error_msg("interface %sappeared",
-						G.iface_exists ? "" : "dis");
+				        G.iface_exists ? "" : "dis");
+
 				if (G.iface_exists)
-					maybe_up_new_iface();
+					maybe_up_iface();
 				else {
 					/* notify upon status:  error -> down */
 					iface_status_old = IFSTATUS_ERR;
@@ -702,34 +696,45 @@
 				}
 			}
 		}
+		else {
+			iface_status = detect_link();
+		}
 
-		/* note: if !G.iface_exists, returns DOWN */
-		iface_status = detect_link();
 		if (iface_status == IFSTATUS_ERR) {
-			if (!(opts & FLAG_MONITOR))
+			if (opts & FLAG_MONITOR)
+				iface_status = IFSTATUS_DOWN;
+			else
 				goto exiting;
-
-			iface_status = IFSTATUS_DOWN;
 		}
-		iface_status_str = strstatus(iface_status);
 
 		if (iface_status_old != iface_status) {
-			bb_error_msg("link is %s", iface_status_str);
+			bb_error_msg("link is %s", strstatus(iface_status));
+
+			if (iface_status == IFSTATUS_DORMANT) {
+				//iface_status = iface_status_old;
+				continue; /* ignore for now */
+			}
 
 			if (delay_time) {
 				/* link restored its old status before
 				 * we run script. don't run the script: */
-				delay_time = 0;
-			} else {
+				 delay_time = 0;
+			}
+			else {
 				delay_time = monotonic_sec();
-				if (iface_status == IFSTATUS_UP)
+
+				if (iface_status >= IFSTATUS_UP) {
+					iface_status = IFSTATUS_UP;
 					delay_time += G.delay_up;
+				}
 				if (iface_status == IFSTATUS_DOWN)
 					delay_time += G.delay_down;
+
 				if (delay_time == 0)
 					delay_time++;
 			}
 		}
+		iface_status_str = strstatus(iface_status);
 
 		if (delay_time && (int)(monotonic_sec() - delay_time) >= 0) {
 			delay_time = 0;
