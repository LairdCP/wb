diff -urN a/drivers/net/wireless/ath/ath6kl/cfg80211.c b/drivers/net/wireless/ath/ath6kl/cfg80211.c
--- a/drivers/net/wireless/ath/ath6kl/cfg80211.c	2013-04-18 21:46:36.691077669 -0500
+++ b/drivers/net/wireless/ath/ath6kl/cfg80211.c	2013-05-04 10:41:04.761419788 -0500
@@ -784,6 +784,10 @@
 		cfg80211_roamed_bss(vif->ndev, bss, assoc_req_ie, assoc_req_len,
 				    assoc_resp_ie, assoc_resp_len, GFP_KERNEL);
 	}
+
+#ifdef LAIRD_FIPS
+	if (fips_mode) laird_setbssid(bssid);
+#endif
 }
 
 static int ath6kl_cfg80211_disconnect(struct wiphy *wiphy,
@@ -822,6 +826,10 @@
 
 	vif->sme_state = SME_DISCONNECTED;
 
+#ifdef LAIRD_FIPS
+	if (fips_mode) laird_setbssid(NULL);
+#endif
+
 	return 0;
 }
 
@@ -1141,6 +1149,13 @@
 	memcpy(key->seq, params->seq, key->seq_len);
 	key->cipher = params->cipher;
 
+#ifdef LAIRD_FIPS 
+	if (fips_mode) {
+		laird_addkey(ndev, key_index, pairwise, mac_addr, 
+					 key->key, key->key_len, key->seq, key->seq_len); 
+	}
+#endif 
+
 	switch (key->cipher) {
 	case WLAN_CIPHER_SUITE_WEP40:
 	case WLAN_CIPHER_SUITE_WEP104:
@@ -1240,6 +1255,12 @@
 
 	vif->keys[key_index].key_len = 0;
 
+#ifdef LAIRD_FIPS
+	if (fips_mode) {
+		laird_delkey(ndev, key_index);
+	}
+#endif
+
 	return ath6kl_wmi_deletekey_cmd(ar->wmi, vif->fw_vif_idx, key_index);
 }
 
diff -urN a/drivers/net/wireless/ath/ath6kl/common.h b/drivers/net/wireless/ath/ath6kl/common.h
--- a/drivers/net/wireless/ath/ath6kl/common.h	2013-04-18 21:46:36.691077669 -0500
+++ b/drivers/net/wireless/ath/ath6kl/common.h	2013-05-04 10:41:04.769419787 -0500
@@ -83,4 +83,7 @@
 struct ath6kl_htc_credit_info;
 
 struct sk_buff *ath6kl_buf_alloc(int size);
+
+#include "laird.h"
+
 #endif /* COMMON_H */
diff -urN a/drivers/net/wireless/ath/ath6kl/core.c b/drivers/net/wireless/ath/ath6kl/core.c
--- a/drivers/net/wireless/ath/ath6kl/core.c	2013-04-18 21:46:36.711078650 -0500
+++ b/drivers/net/wireless/ath/ath6kl/core.c	2013-05-13 08:35:48.355413313 -0500
@@ -27,6 +27,8 @@
 #include "htc-ops.h"
 #include "cfg80211.h"
 
+#include "laird.h"
+
 unsigned int debug_mask;
 static unsigned int suspend_mode;
 static unsigned int wow_mode;
@@ -344,3 +346,19 @@
 MODULE_AUTHOR("Qualcomm Atheros");
 MODULE_DESCRIPTION("Core module for AR600x SDIO and USB devices.");
 MODULE_LICENSE("Dual BSD/GPL");
+
+#ifdef LAIRD_FIPS
+// module parameter for enabling fips mode on load
+bool fips_mode = 0;
+module_param(fips_mode, bool, S_IRUGO);
+
+// function called by external module to register fips support
+const laird_register_data_t *laird_register_data;
+int ath6kl_laird_register(const laird_register_data_t *ptr)
+{
+	laird_register_data = ptr;
+	return 0;
+}
+EXPORT_SYMBOL(ath6kl_laird_register);
+
+#endif
diff -urN a/drivers/net/wireless/ath/ath6kl/init.c b/drivers/net/wireless/ath/ath6kl/init.c
--- a/drivers/net/wireless/ath/ath6kl/init.c	2013-04-18 21:46:36.691077669 -0500
+++ b/drivers/net/wireless/ath/ath6kl/init.c	2013-05-13 08:35:48.351413313 -0500
@@ -32,6 +32,8 @@
 #include "hif-ops.h"
 #include "htc-ops.h"
 
+#include "laird.h"
+
 static const struct ath6kl_hw hw_list[] = {
 	{
 		.id				= AR6003_HW_2_0_VERSION,
@@ -1759,6 +1761,13 @@
 		return;
 	}
 
+#ifdef LAIRD_FIPS
+	if (fips_mode) {
+		// wait for all fips in progress txrx to complete
+		laird_stop_txrx();
+	}
+#endif
+
 	for (i = 0; i < AP_MAX_NUM_STA; i++)
 		aggr_reset_state(ar->sta_list[i].aggr_conn);
 
diff -urN a/drivers/net/wireless/ath/ath6kl/laird_common.h b/drivers/net/wireless/ath/ath6kl/laird_common.h
--- a/drivers/net/wireless/ath/ath6kl/laird_common.h	1969-12-31 18:00:00.000000000 -0600
+++ b/drivers/net/wireless/ath/ath6kl/laird_common.h	2013-05-06 16:12:15.954922463 -0500
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2012 Laird Technologies, Inc.
+ */
+#ifndef LAIRD_COMMON_H
+#define LAIRD_COMMON_H
+
+#ifdef LAIRD_FIPS
+
+// res<0 to fail packet, else continue receive
+typedef void (*pfn_laird_skb_rx_continue)(struct sk_buff *skb, int res);
+
+// transmit: continue transmit after encryption/encapsulation
+// routine in driver
+// isfips=-1 to fail the skb
+// isfips=1 to indicate that skb has been encrypted/encapsulated in 802.11
+typedef int (*pfn_laird_skb_tx_continue)(
+    struct sk_buff *skb, struct net_device *dev, int isfips);
+
+// receive: laird_skb_rx will return non-zero to let driver process packet
+// return<0 if a failure occurs
+// 0 on success and pfncb will be called later (possibly not with same skb)
+typedef int (*pfn_laird_skb_rx_prep)(
+	struct sk_buff *skb, pfn_laird_skb_rx_continue pfncb);
+
+// transmit: prepare sk_buff -- encryption/encapsulation
+// return<0 if a failure occurs
+// 0 on success and pfncb will be called later (possibly not with same skb)
+typedef int (*pfn_laird_skb_tx_prep)(
+	struct sk_buff *skb, struct net_device *dev, int wmm,
+	pfn_laird_skb_tx_continue pfncb);
+
+// transmit: flow control
+typedef void (*pfn_laird_stop_queue)(struct net_device *dev);
+typedef void (*pfn_laird_wake_queue)(struct net_device *dev);
+
+// key operations
+typedef void (*pfn_laird_addkey)(struct net_device *ndev, u8 key_index,
+                         bool pairwise,
+                         const u8 *mac_addr,
+                         const u8 *key, int keylen,
+                         const u8 *seq, int seqlen);
+typedef void (*pfn_laird_delkey)(struct net_device *ndev, u8 key_index);
+
+// bssid
+typedef void (*pfn_laird_setbssid)(const u8 *bssid);
+
+// stopping the driver (rmmod) support
+typedef int (*pfn_laird_stop_txrx)(void);
+
+typedef struct {
+	pfn_laird_skb_rx_prep pfn_rx_prep;
+	pfn_laird_skb_tx_prep pfn_tx_prep;
+	pfn_laird_stop_queue pfn_stop_queue;
+	pfn_laird_wake_queue pfn_wake_queue;
+	pfn_laird_addkey pfn_addkey;
+	pfn_laird_delkey pfn_delkey;
+	pfn_laird_setbssid pfn_setbssid;
+	pfn_laird_stop_txrx pfn_stop_txrx;
+} laird_register_data_t;
+
+// external driver function that the laird module will call
+extern int ath6kl_laird_register(const laird_register_data_t *ptr);
+
+#endif // LAIRD_FIPS
+#endif /* LAIRD_COMMON_H */
+
diff -urN a/drivers/net/wireless/ath/ath6kl/laird.h b/drivers/net/wireless/ath/ath6kl/laird.h
--- a/drivers/net/wireless/ath/ath6kl/laird.h	1969-12-31 18:00:00.000000000 -0600
+++ b/drivers/net/wireless/ath/ath6kl/laird.h	2013-05-06 16:12:15.950922462 -0500
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2012 Laird Technologies, Inc.
+ */
+#ifndef LAIRD_DRIVER_H
+#define LAIRD_DRIVER_H
+
+
+#ifdef LAIRD_FIPS
+#include <linux/etherdevice.h>
+#include "laird_common.h"
+
+extern bool fips_mode;
+extern const laird_register_data_t *laird_register_data;
+
+// receive: laird_skb_rx will return non-zero to let driver process packet
+static inline int  laird_skb_rx_prep(struct sk_buff *skb, pfn_laird_skb_rx_continue pfncb)
+{
+	if (!laird_register_data) return -1;
+	if (!laird_register_data->pfn_rx_prep) return -1;
+	return (*(laird_register_data->pfn_rx_prep))(skb, pfncb);
+}
+
+// transmit: prepare sk_buff -- encryption/encapsulation
+static inline int laird_skb_encrypt_prep(struct sk_buff *skb, struct net_device *dev, int wmm, pfn_laird_skb_tx_continue pfncb)
+{
+	if (!laird_register_data) return -1;
+	if (!laird_register_data->pfn_tx_prep) return -1;
+	return (*(laird_register_data->pfn_tx_prep))(skb, dev, wmm, pfncb);
+}
+
+// transmit: flow control
+static inline void laird_stop_queue(struct net_device *dev)
+{
+	if (!laird_register_data) return;
+	if (!laird_register_data->pfn_stop_queue) return;
+	return (*(laird_register_data->pfn_stop_queue))(dev);
+}
+
+static inline void laird_wake_queue(struct net_device *dev)
+{
+	if (!laird_register_data) return;
+	if (!laird_register_data->pfn_wake_queue) return;
+	(*(laird_register_data->pfn_wake_queue))(dev);
+}
+
+// key operations
+static inline void laird_addkey(struct net_device *ndev, u8 key_index,
+                         bool pairwise,
+                         const u8 *mac_addr,
+                         const u8 *key, int keylen,
+                         const u8 *seq, int seqlen)
+{
+	if (!laird_register_data) return;
+	if (!laird_register_data->pfn_addkey) return;
+	(*(laird_register_data->pfn_addkey))
+		(ndev, key_index, pairwise, mac_addr, key, keylen, seq, seqlen);
+}
+
+static inline void laird_delkey(struct net_device *ndev, u8 key_index)
+{
+	if (!laird_register_data) return;
+	if (!laird_register_data->pfn_delkey) return;
+	(*(laird_register_data->pfn_delkey))(ndev, key_index);
+}
+
+// bssid
+static inline void laird_setbssid(const u8 *bssid)
+{
+	if (!laird_register_data) return;
+	if (!laird_register_data->pfn_setbssid) return;
+	(*(laird_register_data->pfn_setbssid))(bssid);
+}
+
+// stopping the driver (rmmod) support
+static inline void laird_stop_txrx(void)
+{
+	if (!laird_register_data) return;
+	if (!laird_register_data->pfn_stop_txrx) return;
+	(*(laird_register_data->pfn_stop_txrx))();
+}
+
+#endif // LAIRD_FIPS
+#endif /* LAIRD_DRIVER_H */
diff -urN a/drivers/net/wireless/ath/ath6kl/main.c b/drivers/net/wireless/ath/ath6kl/main.c
--- a/drivers/net/wireless/ath/ath6kl/main.c	2013-04-18 21:46:36.711078650 -0500
+++ b/drivers/net/wireless/ath/ath6kl/main.c	2013-05-04 10:41:04.765419788 -0500
@@ -22,6 +22,7 @@
 #include "cfg80211.h"
 #include "target.h"
 #include "debug.h"
+#include "laird.h"
 
 struct ath6kl_sta *ath6kl_find_sta(struct ath6kl_vif *vif, u8 *node_addr)
 {
@@ -1326,11 +1327,23 @@
 	dev->destructor = free_netdev;
 	dev->watchdog_timeo = ATH6KL_TX_TIMEOUT;
 
+#ifdef LAIRD_FIPS
+	if (fips_mode) {
+		// TBD: fix with correct header length
+		dev->needed_headroom = 32 + 8;
+		// need tailroom for adding ICV
+		dev->needed_tailroom = 8;
+	} else
+#endif
 	dev->needed_headroom = ETH_HLEN;
 	dev->needed_headroom += sizeof(struct ath6kl_llc_snap_hdr) +
 				sizeof(struct wmi_data_hdr) + HTC_HDR_LENGTH
 				+ WMI_MAX_TX_META_SZ + ATH6KL_HTC_ALIGN_BYTES;
 
+#ifdef LAIRD_FIPS
+	if (!fips_mode)
+		// can only support hardware ip checksum in non-fips mode
+#endif
 	dev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_RXCSUM;
 
 	return;
diff -urN a/drivers/net/wireless/ath/ath6kl/Makefile b/drivers/net/wireless/ath/ath6kl/Makefile
--- a/drivers/net/wireless/ath/ath6kl/Makefile	2013-04-18 21:46:36.711078650 -0500
+++ b/drivers/net/wireless/ath/ath6kl/Makefile	2013-05-13 08:35:48.355413313 -0500
@@ -42,3 +42,7 @@
 
 obj-$(CONFIG_ATH6KL_USB) += ath6kl_usb.o
 ath6kl_usb-y += usb.o
+
+ccflags-y += -DLAIRD_FIPS
+#ccflags-y += -DCONFIG_ATH6KL_DEBUG
+
diff -urN a/drivers/net/wireless/ath/ath6kl/txrx.c b/drivers/net/wireless/ath/ath6kl/txrx.c
--- a/drivers/net/wireless/ath/ath6kl/txrx.c	2013-04-18 21:46:36.691077669 -0500
+++ b/drivers/net/wireless/ath/ath6kl/txrx.c	2013-05-13 08:35:48.355413313 -0500
@@ -21,6 +21,8 @@
 #include "debug.h"
 #include "htc-ops.h"
 
+#include "laird.h"
+
 /*
  * tid - tid_mux0..tid_mux3
  * aid - tid_mux4..tid_mux7
@@ -348,7 +350,13 @@
 	return status;
 }
 
+#ifdef LAIRD_FIPS
+int laird_data_tx_continue(struct sk_buff *skb, 
+						   struct net_device *dev,
+						   int isfips)
+#else
 int ath6kl_data_tx(struct sk_buff *skb, struct net_device *dev)
+#endif
 {
 	struct ath6kl *ar = ath6kl_priv(dev);
 	struct ath6kl_cookie *cookie = NULL;
@@ -365,6 +373,11 @@
 	u8 meta_ver = 0;
 	u32 flags = 0;
 
+#ifdef LAIRD_FIPS
+	if (isfips < 0) // check if fips encryption failed
+		goto fail_tx;
+#endif
+
 	ath6kl_dbg(ATH6KL_DBG_WLAN_TX,
 		   "%s: skb=0x%p, data=0x%p, len=0x%x\n", __func__,
 		   skb, skb->data, skb->len);
@@ -386,6 +399,12 @@
 	}
 
 	if (test_bit(WMI_ENABLED, &ar->flag)) {
+#ifdef LAIRD_FIPS
+		if (isfips)
+			goto fips_skip1;
+
+		// only do the following for non-fips mode
+#endif
 		if ((dev->features & NETIF_F_IP_CSUM) &&
 		    (csum == CHECKSUM_PARTIAL)) {
 			csum_start = skb->csum_start -
@@ -410,6 +429,10 @@
 			goto fail_tx;
 		}
 
+#ifdef LAIRD_FIPS
+	fips_skip1: // contunue fips processing here
+#endif /* LAIRD_FIPS */
+	 
 		if ((dev->features & NETIF_F_IP_CSUM) &&
 		    (csum == CHECKSUM_PARTIAL)) {
 			meta_v2.csum_start = csum_start;
@@ -424,8 +447,14 @@
 			meta = NULL;
 		}
 
+#ifdef LAIRD_FIPS
+#define LAIRD_HDR_TYPE (isfips ? WMI_DATA_HDR_DATA_TYPE_802_11 : 0)
+#else
+#define LAIRD_HDR_TYPE 0
+#endif /* LAIRD_FIPS */
+
 		ret = ath6kl_wmi_data_hdr_add(ar->wmi, skb,
-				DATA_MSGTYPE, flags, 0,
+				DATA_MSGTYPE, flags, LAIRD_HDR_TYPE,
 				meta_ver,
 				meta, vif->fw_vif_idx);
 
@@ -520,6 +549,28 @@
 	return 0;
 }
 
+#ifdef LAIRD_FIPS
+int ath6kl_data_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	struct ath6kl *ar = ath6kl_priv(dev);
+
+	// if not in fips_mode use the normal routine
+	if (!fips_mode) return laird_data_tx_continue(skb, dev, 0);
+
+	// in fips_mode, convert the socket buffer and then continue
+	// TBD: modify call to enable WMM
+	if (laird_skb_encrypt_prep(skb, dev, ar->wmi->is_wmm_enabled,
+			&laird_data_tx_continue)) {
+		// failure -- pass to original routine to handle failure
+		return laird_data_tx_continue(skb, dev, -1);
+	}
+
+	// laird_data_tx_continue() will be called in laird_skb_tx_tasklet()
+
+	return 0;
+}
+#endif
+
 /* indicate tx activity or inactivity on a WMI stream */
 void ath6kl_indicate_tx_activity(void *devt, u8 traffic_class, bool active)
 {
@@ -628,6 +679,12 @@
 			spin_unlock_bh(&ar->list_lock);
 
 			set_bit(NETQ_STOPPED, &vif->flags);
+#ifdef LAIRD_FIPS
+			if (fips_mode) {
+				// also, stop completed fips packets from being submitted
+		        laird_stop_queue(vif->ndev);
+			}
+#endif
 			netif_stop_queue(vif->ndev);
 
 			return action;
@@ -800,6 +857,12 @@
 		if (test_bit(CONNECTED, &vif->flags) &&
 		    !flushing[vif->fw_vif_idx]) {
 			spin_unlock_bh(&ar->list_lock);
+#ifdef LAIRD_FIPS
+			if (fips_mode) {
+				// also, enable completed fips packets to be submitted
+				laird_wake_queue(vif->ndev);
+			}
+#endif
 			netif_wake_queue(vif->ndev);
 			spin_lock_bh(&ar->list_lock);
 		}
@@ -1298,6 +1361,9 @@
 	return;
 }
 
+// for forward reference
+void laird_skb_rx_continue(struct sk_buff *skb, int res);
+
 void ath6kl_rx(struct htc_target *target, struct htc_packet *packet)
 {
 	struct ath6kl *ar = target->dev->ar;
@@ -1542,6 +1608,24 @@
 
 	skb_pull(skb, pad_before_data_start);
 
+#ifdef LAIRD_FIPS
+	if (fips_mode) {
+		int res;
+		res = laird_skb_rx_prep(skb, &laird_skb_rx_continue);
+		if (res == 0) {
+			// will continue in laird_skb_rx_continue
+			return;
+		}
+		if (res < 0) {
+			// failed -- delete packet
+			dev_kfree_skb(skb);
+			return;
+		}
+		// TBD: temporary code for testing...
+		// letting driver finish receive processing
+	}
+#endif
+
 	if (dot11_hdr)
 		status = ath6kl_wmi_dot11_hdr_remove(ar->wmi, skb);
 	else if (!is_amsdu)
@@ -1617,6 +1701,20 @@
 	ath6kl_deliver_frames_to_nw_stack(vif->ndev, skb);
 }
 
+#ifdef LAIRD_FIPS
+// continue receive packet processing
+void laird_skb_rx_continue(struct sk_buff *skb, int res)
+{
+	if (res < 0) {
+		// failed decrypt -- free buffer
+		dev_kfree_skb(skb);
+	} else {
+		// TBD: above is now using vif->ndev ???
+		ath6kl_deliver_frames_to_nw_stack(skb->dev, skb);
+	}
+}
+#endif
+
 static void aggr_timeout(unsigned long arg)
 {
 	u8 i, j;
diff -urN a/drivers/net/wireless/ath/ath6kl/wmi.c b/drivers/net/wireless/ath/ath6kl/wmi.c
--- a/drivers/net/wireless/ath/ath6kl/wmi.c	2013-04-18 21:46:36.687077528 -0500
+++ b/drivers/net/wireless/ath/ath6kl/wmi.c	2013-05-13 08:35:48.355413313 -0500
@@ -271,6 +271,22 @@
 	if (!wmm_enabled) {
 		/* If WMM is disabled all traffic goes as BE traffic */
 		usr_pri = 0;
+#ifdef LAIRD_FIPS
+	} else if (fips_mode) {
+		struct ieee80211_qos_hdr *pwh;
+		pwh = (struct ieee80211_qos_hdr *)(datap +
+							 sizeof(struct
+								wmi_data_hdr) +
+							 meta_size);
+		if (le16_to_cpu(pwh->frame_control) & IEEE80211_STYPE_QOS_DATA) {
+			// qos packet, get priority from qos field
+			usr_pri = le16_to_cpu(pwh->qos_ctrl) & IEEE80211_QOS_CTL_TAG1D_MASK;
+		} else {
+			// non-qos, always use 0
+			usr_pri = 0;
+		}
+		// NOTE: wmm_enabled is still true when associated to non-qos AP
+#endif
 	} else {
 		hdr_size = sizeof(struct ethhdr);
 
@@ -3479,11 +3495,35 @@
 	struct wmi_rx_frame_format_cmd *cmd;
 	int ret;
 
+#ifdef LAIRD_FIPS
+	if (fips_mode) {
+		// Disable A-MSDU when in FIPS mode
+		struct wmi_allow_aggr_cmd *fips_cmd;
+		skb = ath6kl_wmi_get_new_buf(sizeof(*fips_cmd));
+		if (!skb)
+			return -ENOMEM;
+		fips_cmd = (struct wmi_allow_aggr_cmd *) skb->data;
+		/* Disable aggregation for Tx and Rx on all TIDs (one bit each) */
+		fips_cmd->tx_allow_aggr = 0x00;
+		fips_cmd->rx_allow_aggr = 0x00;
+       	ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_ALLOW_AGGR_CMDID,
+				  NO_SYNC_WMIFLAG);	
+	}
+#endif
+
 	skb = ath6kl_wmi_get_new_buf(sizeof(*cmd));
 	if (!skb)
 		return -ENOMEM;
 
 	cmd = (struct wmi_rx_frame_format_cmd *) skb->data;
+#ifdef LAIRD_FIPS
+	if (fips_mode) {
+        // force FIPS mode
+        rx_dot11_hdr = 1;
+        defrag_on_host =1;
+        cmd->reserved[0] = 1;
+	}
+#endif
 	cmd->dot11_hdr = rx_dot11_hdr ? 1 : 0;
 	cmd->defrag_on_host = defrag_on_host ? 1 : 0;
 	cmd->meta_ver = rx_meta_ver;
diff -urN a/drivers/net/wireless/ath/ath6kl/wmi.h b/drivers/net/wireless/ath/ath6kl/wmi.h
--- a/drivers/net/wireless/ath/ath6kl/wmi.h	2013-04-18 21:46:36.687077528 -0500
+++ b/drivers/net/wireless/ath/ath6kl/wmi.h	2013-05-04 10:41:04.757419788 -0500
@@ -2189,6 +2189,17 @@
 	__le16 reason_code;
 } __packed;
 
+#ifdef LAIRD_FIPS
+/* WMI_ALLOW_AGGR_CMDID
+ * Configures tid's to allow ADDBA negotiations
+ * on each tid, in each direction
+ */
+struct wmi_allow_aggr_cmd{
+   u16 tx_allow_aggr; /* 16-bit mask to allow uplink ADDBA negotiation - bit position indicates tid */
+   u16 rx_allow_aggr; /* 16-bit mask to allow downlink ADDBA negotiation - bit position indicates tid */
+} __packed;
+#endif /* LAIRD_FIPS */
+
 #define PEER_NODE_JOIN_EVENT		0x00
 #define PEER_NODE_LEAVE_EVENT		0x01
 #define PEER_FIRST_NODE_JOIN_EVENT	0x10
