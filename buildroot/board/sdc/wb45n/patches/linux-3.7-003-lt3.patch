diff -urN a/arch/arm/boot/dts/at91sam9g25ek.dts b/arch/arm/boot/dts/at91sam9g25ek.dts
--- a/arch/arm/boot/dts/at91sam9g25ek.dts	2012-12-10 22:30:57.000000000 -0500
+++ b/arch/arm/boot/dts/at91sam9g25ek.dts	2012-12-23 21:34:26.000000000 -0500
@@ -28,6 +28,14 @@
 				status = "okay";
 			};
 
+			usart1: serial@f8020000 {
+				status = "okay";
+			};
+
+			usart2: serial@f8024000 {
+				status = "okay";
+			};
+
 			macb0: ethernet@f802c000 {
 				phy-mode = "rmii";
 				status = "okay";
@@ -44,18 +52,42 @@
 			i2c2: i2c@f8018000 {
 				status = "okay";
 			};
+
+			mmc0: mmc@f0008000 {
+				status = "okay";
+				slot@0 {
+					reg = <0>;
+					bus-width = <4>;
+					cd-gpios = <&pioC 11 0>;
+					cd-inverted;
+				};
+			};
+
+			mmc1: mmc@f000c000 {
+				status = "okay";
+				slot@0 {
+					reg = <0>;
+					bus-width = <4>;
+					/* cd-gpios = <&pioC 11 0>; */
+					/* cd-inverted; */
+				};
+			};
 		};
 
 		usb0: ohci@00600000 {
 			status = "okay";
-			num-ports = <2>;
-			atmel,vbus-gpio = <&pioD 19 1
-					   &pioD 20 1
-					  >;
+			num-ports = <2>;
+			atmel,vbus-gpio = <&pioB 12 0 &pioA 31 0>;
+			atmel,oc-gpio = <&pioB 13 1>;
 		};
 
 		usb1: ehci@00700000 {
 			status = "okay";
 		};
 	};
+
+	atheros {
+		compatible = "atheros,ath6kl";
+		atheros,board-id = "SD32";
+	};
 };
diff -urN a/arch/arm/boot/dts/at91sam9x5.dtsi b/arch/arm/boot/dts/at91sam9x5.dtsi
--- a/arch/arm/boot/dts/at91sam9x5.dtsi	2012-12-10 22:30:57.000000000 -0500
+++ b/arch/arm/boot/dts/at91sam9x5.dtsi	2012-12-23 21:34:01.000000000 -0500
@@ -263,6 +263,24 @@
 					trigger-value = <0x6>;
 				};
 			};
+
+			mmc0: mmc@f0008000 {
+				compatible = "atmel,hsmci";
+				reg = <0xf0008000 0x600>;
+				interrupts = <12 4 0>;
+				status = "disabled";
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+
+			mmc1: mmc@f000c000 {
+				compatible = "atmel,hsmci";
+				reg = <0xf000c000 0x600>;
+				interrupts = <26 4 0>;
+				status = "disabled";
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
 		};
 
 		nand0: nand@40000000 {
@@ -270,6 +288,9 @@
 			#address-cells = <1>;
 			#size-cells = <1>;
 			reg = <0x40000000 0x10000000
+				0xffffe000 0x600
+				0xffffe600 0x200
+				0x00100000 0x100000
 			      >;
 			atmel,nand-addr-offset = <21>;
 			atmel,nand-cmd-offset = <22>;
diff -urN a/arch/arm/boot/dts/at91sam9x5cm.dtsi b/arch/arm/boot/dts/at91sam9x5cm.dtsi
--- a/arch/arm/boot/dts/at91sam9x5cm.dtsi	2012-12-10 22:30:57.000000000 -0500
+++ b/arch/arm/boot/dts/at91sam9x5cm.dtsi	2012-12-23 20:58:56.000000000 -0500
@@ -26,33 +26,62 @@
 	ahb {
 		nand0: nand@40000000 {
 			nand-bus-width = <8>;
-			nand-ecc-mode = "soft";
+			nand-ecc-mode = "hw";
+			atmel,has-pmecc;	/* enable PMECC */
+			atmel,pmecc-cap = <4>;
+			atmel,pmecc-sector-size = <512>;
+			atmel,pmecc-lookup-table-offset = <0x8000 0x10000>;
 			nand-on-flash-bbt;
 			status = "okay";
 
 			at91bootstrap@0 {
 				label = "at91bootstrap";
-				reg = <0x0 0x40000>;
+				reg = <0x0 0x20000>;
 			};
 
-			uboot@40000 {
+			uboot@20000 {
 				label = "u-boot";
-				reg = <0x40000 0x80000>;
+				reg = <0x20000 0x80000>;
 			};
 
-			ubootenv@c0000 {
+			ubootenv@a0000 {
 				label = "U-Boot Env";
-				reg = <0xc0000 0x140000>;
+				reg = <0xa0000 0x20000>;
+			};
+
+			ubootenv@c0000 {
+				label = "U-Boot Redund Env";
+				reg = <0xc0000 0x20000>;
+			};
+
+			kernel-a@e0000 {
+				label = "kernel-a";
+				reg = <0xe0000 0x280000>;
+			};
+
+			kernel-b@360000 {
+				label = "kernel-b";
+				reg = <0x360000 0x280000>;
+			};
+
+			rootfs-a@5e0000 {
+				label = "rootfs-a";
+				reg = <0x5e0000 0x2600000>;
+			};
+
+			rootfs-b@2be0000 {
+				label = "rootfs-b";
+				reg = <0x2be0000 0x2600000>;
 			};
 
-			kernel@200000 {
-				label = "kernel";
-				reg = <0x200000 0x600000>;
+			user@51e0000 {
+				label = "user";
+				reg = <0x51e0000 0x2dc0000>;
 			};
 
-			rootfs@800000 {
-				label = "rootfs";
-				reg = <0x800000 0x1f800000>;
+			logs@7fa0000 {
+				label = "logs";
+				reg = <0x7fa0000 0x60000>;
 			};
 		};
 	};
@@ -60,15 +89,15 @@
 	leds {
 		compatible = "gpio-leds";
 
-		pb18 {
-			label = "pb18";
-			gpios = <&pioB 18 1>;
+		pc8 {
+			label = "pc8";
+			gpios = <&pioC 8 1>;
 			linux,default-trigger = "heartbeat";
 		};
 
-		pd21 {
-			label = "pd21";
-			gpios = <&pioD 21 0>;
+		pc14 {
+			label = "pc14";
+			gpios = <&pioC 14 0>;
 		};
 	};
 };
diff -urN a/arch/arm/mach-at91/at91sam9x5.c b/arch/arm/mach-at91/at91sam9x5.c
--- a/arch/arm/mach-at91/at91sam9x5.c	2012-12-10 22:30:57.000000000 -0500
+++ b/arch/arm/mach-at91/at91sam9x5.c	2012-12-11 07:26:34.000000000 -0500
@@ -231,6 +231,8 @@
 	CLKDEV_CON_DEV_ID("t0_clk", "f800c000.timer", &tcb0_clk),
 	CLKDEV_CON_DEV_ID("dma_clk", "ffffec00.dma-controller", &dma0_clk),
 	CLKDEV_CON_DEV_ID("dma_clk", "ffffee00.dma-controller", &dma1_clk),
+	CLKDEV_CON_DEV_ID("mci_clk", "f0008000.mmc", &mmc0_clk),
+	CLKDEV_CON_DEV_ID("mci_clk", "f000c000.mmc", &mmc1_clk),
 	CLKDEV_CON_DEV_ID(NULL, "f8010000.i2c", &twi0_clk),
 	CLKDEV_CON_DEV_ID(NULL, "f8014000.i2c", &twi1_clk),
 	CLKDEV_CON_DEV_ID(NULL, "f8018000.i2c", &twi2_clk),
diff -urN a/drivers/mmc/host/atmel-mci.c b/drivers/mmc/host/atmel-mci.c
--- a/drivers/mmc/host/atmel-mci.c	2012-12-10 22:30:57.000000000 -0500
+++ b/drivers/mmc/host/atmel-mci.c	2012-12-11 07:26:34.000000000 -0500
@@ -2350,6 +2350,13 @@
 		}
 	}
 
+	at91_set_A_periph(AT91_PIN_PA15, 1); /* MCI0_DA0 */
+	at91_set_A_periph(AT91_PIN_PA16, 1); /* MCI0_CMD */
+	at91_set_A_periph(AT91_PIN_PA17, 0); /* MCI0_CLK */
+	at91_set_A_periph(AT91_PIN_PA18, 1); /* MCI0_DA1 */
+	at91_set_A_periph(AT91_PIN_PA19, 1); /* MCI0_DA2 */
+	at91_set_A_periph(AT91_PIN_PA20, 1); /* MCI0_DA3 */
+
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
 		return irq;
diff -urN a/drivers/mtd/nand/atmel_nand.c b/drivers/mtd/nand/atmel_nand.c
--- a/drivers/mtd/nand/atmel_nand.c	2012-12-10 22:30:57.000000000 -0500
+++ b/drivers/mtd/nand/atmel_nand.c	2012-12-11 07:26:34.000000000 -0500
@@ -64,10 +64,10 @@
  * several NAND_CMD_RNDOUT during read
  */
 static struct nand_ecclayout atmel_oobinfo_large = {
-	.eccbytes = 4,
-	.eccpos = {60, 61, 62, 63},
+	.eccbytes = 28,
+	.eccpos = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29},
 	.oobfree = {
-		{2, 58}
+		{30, 34}
 	},
 };
 
diff -urN a/include/uapi/linux/netfilter_bridge/ebt_nat.h b/include/uapi/linux/netfilter_bridge/ebt_nat.h
--- a/include/uapi/linux/netfilter_bridge/ebt_nat.h	2012-12-10 22:30:57.000000000 -0500
+++ b/include/uapi/linux/netfilter_bridge/ebt_nat.h	2012-12-11 07:26:34.000000000 -0500
@@ -9,5 +9,6 @@
 };
 #define EBT_SNAT_TARGET "snat"
 #define EBT_DNAT_TARGET "dnat"
+#define EBT_ARPNAT_TARGET "arpnat"
 
 #endif
diff -urN a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c
--- a/net/bridge/br_fdb.c	2012-12-10 22:30:57.000000000 -0500
+++ b/net/bridge/br_fdb.c	2012-12-11 07:26:34.000000000 -0500
@@ -674,3 +674,4 @@
 
 	return err;
 }
+
diff -urN a/net/bridge/netfilter/Kconfig b/net/bridge/netfilter/Kconfig
--- a/net/bridge/netfilter/Kconfig	2012-12-10 22:30:57.000000000 -0500
+++ b/net/bridge/netfilter/Kconfig	2012-12-11 07:26:34.000000000 -0500
@@ -177,6 +177,16 @@
 	  source address of frames.
 
 	  To compile it as a module, choose M here.  If unsure, say N.
+
+config BRIDGE_EBT_ARPNAT
+	tristate "ebt: arpnat target support"
+	depends on BRIDGE_NF_EBTABLES
+	help
+	  This option adds the ARP match, which allows ARP and RARP header field
+	  filtering
+ 
+	  To compile it as a module, choose M here. If unsure, say N.
+
 #
 # watchers
 #
diff -urN a/net/bridge/netfilter/Makefile b/net/bridge/netfilter/Makefile
--- a/net/bridge/netfilter/Makefile	2012-12-10 22:30:57.000000000 -0500
+++ b/net/bridge/netfilter/Makefile	2012-12-11 07:26:34.000000000 -0500
@@ -27,6 +27,7 @@
 obj-$(CONFIG_BRIDGE_EBT_DNAT) += ebt_dnat.o
 obj-$(CONFIG_BRIDGE_EBT_REDIRECT) += ebt_redirect.o
 obj-$(CONFIG_BRIDGE_EBT_SNAT) += ebt_snat.o
+obj-$(CONFIG_BRIDGE_EBT_ARPNAT) += ebt_arpnat.o
 
 # watchers
 obj-$(CONFIG_BRIDGE_EBT_LOG) += ebt_log.o
diff -urN a/net/bridge/netfilter/ebt_arpnat.c b/net/bridge/netfilter/ebt_arpnat.c
--- a/net/bridge/netfilter/ebt_arpnat.c	1969-12-31 19:00:00.000000000 -0500
+++ b/net/bridge/netfilter/ebt_arpnat.c	2012-12-11 07:26:34.000000000 -0500
@@ -0,0 +1,650 @@
+/*
+ *  ebt_arpnat
+ *
+ *	Authors:
+ *      Kestutis Barkauskas <gpl@wilibox.com>
+ *
+ *  November, 2005
+ *
+ *	Rewritten by:
+ *         Kestutis Barkauskas and Kestutis Kupciunas <gpl@ubnt.com>
+ *
+ *  June, 2010
+ *
+ *      Updated to work with more recent kernel versions (e.g., 2.6.30)
+ *      Ditched entry expiration in favor of wiping entries with duplicate ips, when situation arises
+ *      Fixed arpnat procfs (though both arpnat_cache and arpnat_info are both in root procfs directory now)
+ *      
+ *      Eric Bishop <eric@gargoyle-router.com>
+ *
+ *  September 18, 2011
+ *
+ *      Updated code to work with kernel v3.0.0
+ *      Various bridging structures have changed
+ *      Added debugging information
+ *      Christopher Cole <chris.cole@lairdtech.com>
+ *
+ * February 11, 2012
+ *
+ *      Added DHCP Relay code
+ *      Christopher Cole <chris.cole@lairdtech.com>
+ */
+
+
+
+
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter_bridge/ebtables.h>
+#include <linux/netfilter_bridge/ebt_nat.h>
+#include <linux/module.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/if_pppox.h>
+#include <linux/if_vlan.h>
+#include <linux/rtnetlink.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/proc_fs.h>
+#include <linux/inetdevice.h>
+#include <net/arp.h>
+#include <net/ip.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/in.h>
+#include <net/checksum.h>
+
+
+#include "../br_private.h"
+
+#define STRMAC "%02x:%02x:%02x:%02x:%02x:%02x"
+#define STRIP "%d.%d.%d.%d"
+#define MAC2STR(x) (x)[0],(x)[1],(x)[2],(x)[3],(x)[4],(x)[5]
+#define IP2STR(x) (x)>>24&0xff,(x)>>16&0xff,(x)>>8&0xff,(x)&0xff
+
+#define GIADDR_OFFSET (24)
+#define CHADDR_OFFSET (28)
+
+
+
+//#define ARPNAT_DEBUG 1
+
+
+#ifdef ARPNAT_DEBUG
+static uint8_t debug = 1;
+#else
+static uint8_t debug = 0;
+#endif
+
+
+
+#ifndef __packed
+#define __packed __attribute__((__packed__))
+#endif
+
+static uint8_t chaddr_orig_bootp_relay[6] = {0};
+
+struct arpnat_dat
+{
+	uint32_t ip;
+	uint8_t mac[ETH_ALEN];
+} __packed;
+
+struct mac2ip
+{
+	struct hlist_node node;
+	struct arpnat_dat data;
+};
+
+static HLIST_HEAD(arpnat_table);
+static spinlock_t arpnat_lock = __SPIN_LOCK_UNLOCKED(arpnat_lock);
+
+static uint8_t bootpnat = 1;
+
+static struct mac2ip* find_mac_nat(struct hlist_head* head, const uint8_t* mac)
+{
+	struct mac2ip* tpos;
+	struct mac2ip* result = NULL;
+	struct hlist_node* pos;
+	struct hlist_node* n;
+	hlist_for_each_entry_safe(tpos, pos, n, head, node)
+	{
+		if (memcmp(tpos->data.mac, mac, ETH_ALEN) == 0)
+		{
+			result = tpos;
+			break;
+		}
+	}
+	return result;
+}
+
+static struct mac2ip* find_ip_nat(struct hlist_head* head, uint32_t ip)
+{
+	struct mac2ip* tpos;
+	struct mac2ip* result = NULL;
+	struct hlist_node* pos;
+	struct hlist_node* n;
+
+	hlist_for_each_entry_safe(tpos, pos, n, head, node)
+	{
+		if (tpos->data.ip == ip)
+		{
+			result = tpos;
+			break;
+		}
+	}
+	return result;
+}
+
+
+static void clear_ip_nat(struct hlist_head* head, uint32_t ip)
+{
+	struct mac2ip* tpos;
+	struct hlist_node* pos;
+	struct hlist_node* n;
+
+	hlist_for_each_entry_safe(tpos, pos, n, head, node)
+	{
+		if (tpos->data.ip == ip)
+		{
+			hlist_del(pos);
+	   		kfree(tpos);
+		}
+	}
+}
+
+static void free_arp_nat(struct hlist_head* head)
+{
+	struct mac2ip* tpos;
+	struct hlist_node* pos;
+	struct hlist_node* n;
+	hlist_for_each_entry_safe(tpos, pos, n, head, node)
+	{
+		hlist_del(pos);
+		kfree(tpos);
+	}
+}
+
+static struct mac2ip* update_arp_nat(struct hlist_head* head, const uint8_t* mac, uint32_t ip)
+{
+	struct mac2ip* entry;
+
+	entry = find_mac_nat(head, mac);
+	if (!entry)
+	{
+		clear_ip_nat(head, ip); /* if entries with new ip exist, wipe them */ 
+		entry = kmalloc(sizeof(*entry), GFP_ATOMIC);
+		if (!entry)
+		{
+			return NULL;
+		}
+		INIT_HLIST_NODE(&entry->node);
+		hlist_add_head(&entry->node, head);
+		memcpy(entry->data.mac, mac, ETH_ALEN);
+		entry->data.ip = ip;
+	}
+	else if(entry->data.ip != ip)
+	{
+		clear_ip_nat(head, ip); /* if entries with new ip exist, wipe them */ 
+		entry->data.ip = ip;
+	}
+	return entry;
+}
+
+#ifdef CONFIG_PROC_FS
+
+static void *arpnat_start(struct seq_file *seq, loff_t *loff_pos)
+{
+	static unsigned long counter = 0;
+
+	/* beginning a new sequence ? */	
+	if ( *loff_pos == 0 )
+	{	
+		/* yes => return a non null value to begin the sequence */
+		return &counter;
+	}
+	else
+	{
+		/* no => it's the end of the sequence, return end to stop reading */
+		*loff_pos = 0;
+		return NULL;
+	}
+}
+
+static void *arpnat_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	return NULL;
+}
+
+
+static void arpnat_stop(struct seq_file *seq, void *v)
+{
+	//don't need to do anything
+}
+
+
+static int arpnat_cache_show(struct seq_file *s, void *v)
+{
+	struct mac2ip* tpos;
+	struct hlist_node* pos;
+	struct hlist_node* n;
+	unsigned long flags;
+
+	spin_lock_irqsave(&arpnat_lock, flags);
+	hlist_for_each_entry_safe(tpos, pos, n, &arpnat_table, node)
+	{
+		seq_printf(s, STRMAC"\t"STRIP"\n", MAC2STR(tpos->data.mac), IP2STR(tpos->data.ip));
+	}
+	spin_unlock_irqrestore(&arpnat_lock, flags);
+
+	return 0;
+}
+static int arpnat_info_show(struct seq_file *s, void *v)
+{
+	seq_printf(s, "Debug: %d\nBOOTPNAT: %d\n", debug, bootpnat);
+	return 0;
+}
+
+
+static struct seq_operations arpnat_cache_sops = {
+	.start = arpnat_start,
+	.next  = arpnat_next,
+	.stop  = arpnat_stop,
+	.show  = arpnat_cache_show
+};
+static struct seq_operations arpnat_info_sops = {
+	.start = arpnat_start,
+	.next  = arpnat_next,
+	.stop  = arpnat_stop,
+	.show  = arpnat_info_show
+};
+
+static int arpnat_cache_open(struct inode *inode, struct file* file)
+{
+	return seq_open(file, &arpnat_cache_sops);
+}
+static int arpnat_info_open(struct inode *inode, struct file* file)
+{
+	return seq_open(file, &arpnat_info_sops);
+}
+
+
+static struct file_operations arpnat_cache_fops = {
+	.owner   = THIS_MODULE,
+	.open    = arpnat_cache_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = seq_release
+};
+static struct file_operations arpnat_info_fops = {
+	.owner   = THIS_MODULE,
+	.open    = arpnat_info_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = seq_release
+};
+
+
+
+#endif
+
+
+static unsigned int ebt_target_arpnat(struct sk_buff *pskb, const struct xt_action_param *par)
+{
+	const struct net_device *in  =  par->in;
+	const struct net_device *out =  par->out;
+
+	const struct ebt_nat_info *info = (struct ebt_nat_info *) par->targinfo;
+
+	struct arphdr *ah = NULL;
+	struct arphdr _arph;
+
+
+	//used for target only
+	uint8_t* eth_smac = eth_hdr(pskb)->h_source;
+	uint8_t* eth_dmac = eth_hdr(pskb)->h_dest;
+	uint32_t* arp_sip = NULL;
+	uint8_t* arp_smac = NULL;
+	uint32_t* arp_dip = NULL;
+	uint8_t* arp_dmac = NULL;
+	struct mac2ip* entry = NULL;
+	unsigned long flags;
+
+	/* if it's an arp packet, initialize pointers to arp source/dest ip/mac addresses in skb */
+	if (eth_hdr(pskb)->h_proto == __constant_htons(ETH_P_ARP))
+	{
+		if(debug)
+		{
+			printk("ARPNAT ARP DETECTED\n");
+		}
+		ah = skb_header_pointer(pskb, 0, sizeof(_arph), &_arph);
+		if (ah->ar_hln == ETH_ALEN && ah->ar_pro == htons(ETH_P_IP) && ah->ar_pln == 4)
+		{
+			unsigned char *raw = skb_network_header(pskb);
+			arp_sip = (uint32_t*)(raw + sizeof(struct arphdr) + (arp_hdr(pskb)->ar_hln));
+			arp_smac = raw + sizeof(struct arphdr);
+			arp_dip = (uint32_t*)(raw + sizeof(struct arphdr) + (2*(arp_hdr(pskb)->ar_hln)) + arp_hdr(pskb)->ar_pln);
+			arp_dmac = raw + sizeof(struct arphdr) + arp_hdr(pskb)->ar_hln + arp_hdr(pskb)->ar_pln;
+		}
+		else
+		{
+			ah = NULL;
+		}
+	}
+	
+	if (in)
+	{
+		struct net_bridge_port *in_br_port;
+		in_br_port = br_port_get_rcu(in);
+
+		/* handle input packets */
+		if(debug)
+		{
+			printk("ARPNAT INBOUND DETECTED\n");
+		}
+
+		if (ah)
+		{
+			if(debug)
+			{
+				printk("IN ARPNAT:\n");
+				printk("          arp_smac="STRMAC", arp_dmac="STRMAC"\n", MAC2STR(arp_smac), MAC2STR(arp_dmac));
+				printk("          arp_sip ="STRIP", arp_dip ="STRIP"\n", IP2STR(*arp_sip), IP2STR(*arp_dip));
+				if(ah->ar_op == __constant_htons(ARPOP_REPLY))
+				{
+					printk("          arp_op=reply\n");
+				}
+				else if(ah->ar_op == __constant_htons(ARPOP_REQUEST))
+				{
+					printk("          arp_op=request\n");
+				}
+				else
+				{
+					printk("          arp_op=%d\n", ntohs(ah->ar_op));
+				}
+
+			}
+
+
+			if (inet_confirm_addr( __in_dev_get_rcu(in_br_port->br->dev) , 0, *arp_dip, RT_SCOPE_HOST))
+			{
+				if (debug)
+				{
+					printk("          TO US\n");
+				}
+				return info->target;
+			}
+
+
+			spin_lock_irqsave(&arpnat_lock, flags);
+			entry = find_ip_nat(&arpnat_table, *arp_dip);
+			switch (ah->ar_op)
+			{
+				case __constant_htons(ARPOP_REPLY):
+	 			case __constant_htons(ARPOP_REQUEST):
+				if (entry)
+				{
+					uint32_t dip = *arp_dip;
+					uint32_t sip = inet_select_addr(in_br_port->br->dev, dip, RT_SCOPE_LINK);
+					if (! (eth_dmac[0] & 1))
+					{
+						if (debug)
+						{
+							printk("          "STRMAC" -> "STRMAC"\n", MAC2STR(eth_dmac), MAC2STR(entry->data.mac));
+						}
+						memcpy(arp_dmac, entry->data.mac, ETH_ALEN);
+						memcpy(eth_dmac, entry->data.mac, ETH_ALEN);
+						(pskb)->pkt_type = (dip != sip) ? PACKET_OTHERHOST : (pskb)->pkt_type;
+					}
+					spin_unlock_irqrestore(&arpnat_lock, flags);
+					/*if (dip != sip)
+					{
+						if (debug)
+							printk("SEND ARP REQUEST: "STRIP" -> "STRIP"\n", IP2STR(sip), IP2STR(dip));
+						arp_send(ARPOP_REQUEST, ETH_P_ARP, dip, &in_br_port->br->dev, sip, NULL, in_br_port->br->dev.dev_addr, NULL);
+					}*/
+					return info->target;
+				}
+				break;
+			}
+			spin_unlock_irqrestore(&arpnat_lock, flags);
+		}
+		else if (eth_hdr(pskb)->h_proto == __constant_htons(ETH_P_IP))
+		{
+			struct iphdr *iph = ip_hdr(pskb);
+			struct udphdr *uh = NULL;
+			if (bootpnat && (unsigned char)iph->protocol == (unsigned char)IPPROTO_UDP && !(iph->frag_off & htons(IP_OFFSET)))
+			{
+				uh = (struct udphdr*)((u_int32_t *)iph + iph->ihl);
+				if(uh->dest == htons(67) || uh->dest == htons(68) )
+				{
+					//do something illegal for BOOTP
+					uint32_t* giaddrp = (uint32_t*)(((uint8_t*)uh) + sizeof(*uh) + GIADDR_OFFSET);
+					uint8_t* mac = (uint8_t*)(giaddrp + 1);
+					uint32_t ihl = iph->ihl << 2;
+					uint32_t size = (pskb)->len - ihl;
+					uint32_t orig_daddr = iph->daddr;
+
+					//iph->daddr = 0xffffffff;
+					// Recall the original BOOTP CHADDR
+					memcpy(mac, &chaddr_orig_bootp_relay, ETH_ALEN);
+					if (debug)
+					{
+						printk("IN BOOTPRELAY: "STRMAC"["STRIP"] -> "STRMAC"["STRIP"]\n", MAC2STR(eth_dmac), IP2STR(orig_daddr), MAC2STR(mac), IP2STR(iph->daddr));
+					}
+					memcpy(eth_dmac, mac, ETH_ALEN);
+					*giaddrp = 0;
+					uh->dest = htons(68);
+					iph->check = 0;
+					uh->check = 0;
+					iph->check = ip_fast_csum((uint8_t*)iph, iph->ihl);
+					(pskb)->csum = csum_partial((uint8_t*)iph + ihl, size, 0);
+					uh->check = csum_tcpudp_magic(iph->saddr, iph->daddr, size, iph->protocol, (pskb)->csum);
+					
+					if (uh->check == 0)
+					{
+						uh->check = 0xFFFF;
+					}
+					return info->target;
+				}
+				else
+				{
+					goto HANDLE_IP_PKT;
+				}
+			}	
+			else
+			{
+				HANDLE_IP_PKT:
+				spin_lock_irqsave(&arpnat_lock, flags);
+				entry = find_ip_nat(&arpnat_table, iph->daddr);
+				if (entry)
+				{
+					if (inet_confirm_addr( __in_dev_get_rcu(in_br_port->br->dev),  0, entry->data.ip, RT_SCOPE_HOST))
+					{
+						//to me
+						if (debug)
+						{
+							printk("IP PKT TO ME: "STRMAC"["STRIP"] -> "STRMAC"[type: %d]\n", MAC2STR(eth_dmac), IP2STR(iph->daddr), MAC2STR(in_br_port->br->dev->dev_addr), (pskb)->pkt_type);
+						}
+						memcpy(eth_dmac, in_br_port->br->dev->dev_addr, ETH_ALEN);
+					}
+					else
+					{
+						if (debug)
+						{
+							printk("IP PKT TO OTHER: "STRMAC"["STRIP"] -> "STRMAC"[type: %d]\n", MAC2STR(eth_dmac), IP2STR(iph->daddr), MAC2STR(entry->data.mac), (pskb)->pkt_type);
+						}
+						memcpy(eth_dmac, entry->data.mac, ETH_ALEN);
+						(pskb)->pkt_type = PACKET_OTHERHOST;
+					}
+					spin_unlock_irqrestore(&arpnat_lock, flags);
+					return info->target;
+				}
+				spin_unlock_irqrestore(&arpnat_lock, flags);
+			}
+		}
+		
+		if (! (eth_dmac[0] & 1))
+		{
+			if (memcmp(in_br_port->br->dev->dev_addr, eth_dmac, ETH_ALEN) && memcmp(in->dev_addr, eth_dmac, ETH_ALEN))
+			{
+				return EBT_DROP;
+			}
+			spin_lock_irqsave(&arpnat_lock, flags);
+			entry = find_mac_nat(&arpnat_table, eth_dmac);
+			if (entry)
+			{
+				memcpy(eth_dmac, entry->data.mac, ETH_ALEN);
+			}
+			else
+			{
+				memcpy(eth_dmac, in_br_port->br->dev->dev_addr, ETH_ALEN);
+			}
+			spin_unlock_irqrestore(&arpnat_lock, flags);
+		}
+	}
+	else if (out)
+	{
+		struct net_bridge_port *out_br_port;
+		out_br_port = br_port_get_rcu(out);
+
+
+		/* handle outbound packets */
+		if (ah)
+		{
+			switch (ah->ar_op)
+			{
+				case __constant_htons(ARPOP_REQUEST):
+				case __constant_htons(ARPOP_REPLY):
+
+				
+				/* do BR ip lookup */
+				if(inet_confirm_addr( __in_dev_get_rcu(out_br_port->br->dev), 0, *arp_dip, RT_SCOPE_HOST))
+				{
+					return info->target;
+				}
+				if(!inet_confirm_addr( __in_dev_get_rcu(out_br_port->br->dev), 0, *arp_sip, RT_SCOPE_HOST))
+				{
+					spin_lock_irqsave(&arpnat_lock, flags);
+					update_arp_nat(&arpnat_table, arp_smac, *arp_sip);
+					spin_unlock_irqrestore(&arpnat_lock, flags);
+				}
+
+				//pskb = skb_unshare(pskb, GFP_ATOMIC);
+				eth_smac = eth_hdr(pskb)->h_source;
+				arp_smac = skb_network_header(pskb) + sizeof(struct arphdr);
+				if (debug)
+				{
+					printk("OUT ARPNAT: "STRMAC" -> "STRMAC"\n", MAC2STR(eth_smac), MAC2STR(out->dev_addr));
+					printk("           arp_smac="STRMAC", arp_dmac="STRMAC"\n", MAC2STR(arp_smac), MAC2STR(arp_dmac));
+					printk("           arp_sip ="STRIP", arp_dip ="STRIP"\n", IP2STR(*arp_sip), IP2STR(*arp_dip));
+					if(ah->ar_op == __constant_htons(ARPOP_REPLY))
+					{
+						printk("           arp_op=reply\n");
+					}
+					else if(ah->ar_op == __constant_htons(ARPOP_REQUEST))
+					{
+						printk("           arp_op=request\n");
+					}
+					else
+					{
+						printk("           arp_op=%d\n", ntohs(ah->ar_op));
+					}
+				}
+				memcpy(arp_smac, out->dev_addr, ETH_ALEN);
+				memcpy(eth_smac, out->dev_addr, ETH_ALEN);
+				return info->target;
+				break;
+			}
+		}
+		else if (bootpnat && eth_hdr(pskb)->h_proto == __constant_htons(ETH_P_IP) && memcmp(out_br_port->br->dev->dev_addr, eth_smac, ETH_ALEN))
+		{
+			struct iphdr *iph = ip_hdr(pskb);
+			struct udphdr *uh = NULL;
+			if ( (unsigned char)iph->protocol == (unsigned char)IPPROTO_UDP && !(iph->frag_off & htons(IP_OFFSET)))
+			{
+				uh = (struct udphdr*)((u_int32_t *)iph + iph->ihl);
+				if (uh->dest == htons(67) || uh->dest == htons(68) )
+				{
+					//do something illegal for BOOTP
+					uint32_t giaddr = inet_select_addr(out_br_port->br->dev, iph->daddr, RT_SCOPE_LINK);
+					uint32_t* giaddrp = (uint32_t*)(((uint8_t*)uh) + sizeof(*uh) + GIADDR_OFFSET);
+					uint8_t *chaddrp = (uint8_t*)(((uint8_t*)uh) + sizeof(*uh) + CHADDR_OFFSET);
+					uint32_t ihl = iph->ihl << 2;
+					uint32_t size = (pskb)->len - ihl;
+					if (debug)
+					{
+						printk("OUT BOOTPRELAY: "STRIP" -> "STRIP"\n", IP2STR(*giaddrp), IP2STR(giaddr));
+					}
+					*giaddrp = giaddr;
+					// Save off the original BOOTP CHADDR
+					memcpy(&chaddr_orig_bootp_relay, chaddrp, ETH_ALEN);
+					// Change the DHCP HWADDR of the requestor to the HDADDR of the out device
+					memcpy(chaddrp, out->dev_addr, ETH_ALEN);
+
+					/* Fix the checksum */
+					uh->check = 0;
+					(pskb)->csum = csum_partial((uint8_t*)iph + ihl, size, 0);
+					uh->check = csum_tcpudp_magic(iph->saddr, iph->daddr, size, iph->protocol, (pskb)->csum);
+					
+					if (uh->check == 0)
+					{
+						uh->check = 0xFFFF;
+					}
+				}
+			}
+		}
+		memcpy(eth_smac, out->dev_addr, ETH_ALEN);
+	}
+	return info->target;
+}
+
+static int ebt_target_nat_arpcheck(const struct xt_tgchk_param *par)
+{
+	return 0;
+}
+static struct xt_target arpnat =
+{
+	.name		= EBT_ARPNAT_TARGET,
+	.revision	= 0,
+	.family		= NFPROTO_BRIDGE,
+	.table		= "nat",
+	.hooks		= (1 << NF_BR_NUMHOOKS) | (1 << NF_BR_POST_ROUTING) |  (1 << NF_BR_PRE_ROUTING) ,
+	.target		= ebt_target_arpnat, 
+	.checkentry	= ebt_target_nat_arpcheck,
+	.targetsize	= XT_ALIGN(sizeof(struct ebt_nat_info)),
+	.me		= THIS_MODULE
+};
+
+static int __init init(void)
+{
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *proc_arpnat_info  = create_proc_entry("arpnat_info", 0, NULL);
+	struct proc_dir_entry *proc_arpnat_cache = create_proc_entry("arpnat_cache", 0, NULL);
+	if(proc_arpnat_info)
+	{
+		proc_arpnat_info->proc_fops = &arpnat_info_fops;
+	}
+	
+	if(proc_arpnat_cache)
+	{
+		proc_arpnat_cache->proc_fops = &arpnat_cache_fops;
+	}
+#endif
+	return xt_register_target(&arpnat);
+}
+
+static void __exit fini(void)
+{
+	xt_unregister_target(&arpnat);
+	free_arp_nat(&arpnat_table);
+#ifdef CONFIG_PROC_FS
+	remove_proc_entry("arpnat_info", NULL);
+	remove_proc_entry("arpnat_cache", NULL);
+#endif
+}
+
+module_init(init);
+module_exit(fini);
+MODULE_LICENSE("GPL");
+
+
diff -urN a/net/wireless/core.c b/net/wireless/core.c
--- a/net/wireless/core.c	2012-12-10 22:30:57.000000000 -0500
+++ b/net/wireless/core.c	2012-12-11 07:26:34.000000000 -0500
@@ -859,8 +859,7 @@
 		if (!dev->ethtool_ops)
 			dev->ethtool_ops = &cfg80211_ethtool_ops;
 
-		if ((wdev->iftype == NL80211_IFTYPE_STATION ||
-		     wdev->iftype == NL80211_IFTYPE_P2P_CLIENT ||
+		if ((wdev->iftype == NL80211_IFTYPE_P2P_CLIENT ||
 		     wdev->iftype == NL80211_IFTYPE_ADHOC) && !wdev->use_4addr)
 			dev->priv_flags |= IFF_DONT_BRIDGE;
 		break;
diff -urN a/net/wireless/nl80211.c b/net/wireless/nl80211.c
--- a/net/wireless/nl80211.c	2012-12-10 22:30:57.000000000 -0500
+++ b/net/wireless/nl80211.c	2012-12-11 07:26:34.000000000 -0500
@@ -1881,8 +1881,6 @@
 			       enum nl80211_iftype iftype)
 {
 	if (!use_4addr) {
-		if (netdev && (netdev->priv_flags & IFF_BRIDGE_PORT))
-			return -EBUSY;
 		return 0;
 	}
 
diff -urN a/net/wireless/util.c b/net/wireless/util.c
--- a/net/wireless/util.c	2012-12-10 22:30:57.000000000 -0500
+++ b/net/wireless/util.c	2012-12-11 07:26:34.000000000 -0500
@@ -813,7 +813,6 @@
 	/* if it's part of a bridge, reject changing type to station/ibss */
 	if ((dev->priv_flags & IFF_BRIDGE_PORT) &&
 	    (ntype == NL80211_IFTYPE_ADHOC ||
-	     ntype == NL80211_IFTYPE_STATION ||
 	     ntype == NL80211_IFTYPE_P2P_CLIENT))
 		return -EBUSY;
 
@@ -861,14 +860,11 @@
 	if (!err) {
 		dev->priv_flags &= ~IFF_DONT_BRIDGE;
 		switch (ntype) {
-		case NL80211_IFTYPE_STATION:
-			if (dev->ieee80211_ptr->use_4addr)
-				break;
-			/* fall through */
 		case NL80211_IFTYPE_P2P_CLIENT:
 		case NL80211_IFTYPE_ADHOC:
 			dev->priv_flags |= IFF_DONT_BRIDGE;
 			break;
+		case NL80211_IFTYPE_STATION:
 		case NL80211_IFTYPE_P2P_GO:
 		case NL80211_IFTYPE_AP:
 		case NL80211_IFTYPE_AP_VLAN:
