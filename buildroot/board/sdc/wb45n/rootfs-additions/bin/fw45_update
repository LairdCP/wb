#!/usr/bin/env ash
# temporary version of fw_update for wa release
# Jon Hefling, jon.hefling@lairdtech.com, 29-Jun'12
#
#
FIFO=/tmp/update_fifo

# firmware-update-list file containing md5sums
FWUL=/tmp/fw.txt

# image files
BOOTSTRAP_IMG=bootstrap.bin
UBOOT_IMG=u-boot.bin
KERNEL_IMG=kernel.bin
ROOTFS_IMG=rootfs.bin

# firmware-utilities
FW_PRINTENV=/usr/sbin/fw_printenv
FW_SETENV=/usr/sbin/fw_setenv
NANDWRITE=/usr/sbin/nandwrite
FLASH_ERASE=/usr/sbin/flash_erase

# wget and ns
WGET=/usr/bin/wget
WGET_RETRIES=1
NS_PORT=2012
NWBPS=1000000


# arg1 is optional exit context message
exit_okay() {
  rm -f $FIFO
  [ -n "$1" ] && echo -e "$1"
  #if [ -n "$nsap" ]
  #then
  # $0 --ns $nsap update_pending
  # echo "updating platform parameters...11s"
  # rum=$( nc -l -w 11 -p ${nsap##*:} 2>/dev/null |sed -n "/->|<-\ */s/^.....\ *//p" )
    $FW_SETENV updated_% "nsap=$nsap $rum"
  # read -t 3 -n 1 -s -p "Rebooting in 3s...[Y/n]? " a
  # echo -en "\033[1K\r"
  # [ "$a" != "n" ] && ${tm} reboot
  #fi
  exit 0
}

# arg1 is optional error context message
exit_error() {
  rm -f $FIFO
  [ -n "$1" ] && echo -e "$1"
#  [ -n "$nsap" ] && $0 --ns $nsap update_error
  exit 1
}

xml_notification()
{
  name=wb
  [ -n "$1" ] && status="<status>$1</status>"
  [ -n "$2" ] && message="<message>$2</message>"
  cat <<__END-OF-XML-NOTIFICATION-BLOCK
  <$name id=`cat /sys/class/net/eth0/address 2>/dev/null`>
    <version>`cat /etc/summit-release 2>/dev/null`</version>
    $message
    $status
  </$name>
__END-OF-XML-NOTIFICATION-BLOCK
}

# options
case $1 in
  --help) ## usage info
    echo "Notice: This is a temporary version of the update utility for wb45n only!"
    echo
    echo "For using local image file(s) to update, must be run in the same directory."
    echo "If a \"${FWUL##*/}\" (firmware-update-list) file is given or found, it will"
    echo "be used to download the remote image file(s) to update." 
    echo "Usage:"
    echo "  ${0##*/} [--url <web_address/path/version/${FWUL##*/}>]"
    exit 0
    ;;
  --url) ## remote upgrade via http-or-ftp <://server/path/fw.txt>
    if [ -z "$2" ]
    then
      exit_error "Specify URL to retrieve the firmware-update-list from."
    fi
    # expected format:
    # <wget-address/path/version/firmware-update-list> [address:port>]
    # try to parse optionally given nsap and an implied nsap as backup
    nsap="${2##*${FWUL##*/}} $( echo ~nsap=${2##*//} |cut -d/ -f1 ):$NS_PORT "
    [ -n "$tm" ] && echo --url nsap: $nsap
    nsap=$( echo "$nsap" |sed -n "s/.*nsap=\(.*:[0-9]*\) .*/\1/p" )
    [ -n "$tm" ] && echo --url nsap: $nsap
    # compare version string in url with local version (summit-release)
    # the version check here is optional, and defaults to a mis-match
    #remote_version=$( echo $2 |sed -n "s/.*\/\(.*\)\/${FWUL##*/}.*/\1/p" )
    #local_version=$( sed -n 's/.*[ ]\(.*\)/\1/p' /etc/summit-release 2>/dev/null )
    #if [ -z "$remote_version" ]
    #then
    #  echo $2 |grep ${FWUL##*/} \
    #  && exit_error "Unable to compare version of ${FWUL##*/} in URL." \
    #  || exit_error "Error: must specify a valid URL for ${FWUL##*/} file."
    #else
    #  if [ "$remote_version" == "$local_version" ]
    #  then
    #    exit_okay "The remote firmware verson $remote_version is the same as local version."
    #  fi
    #  # update version acceptable because local is different or missing
      fwul_url=$2
      shift 2
    fi
    ;;
  --ns) ## notify remote via udp <addr:port> <state> [<message>]
    shift; sync
    #if [ $# -lt 2 ]
    #then
      exit_error "Invalid parameters for ns mode"
    #else
    #  nc -u $1 -e echo $( xml_notification $2 "$3" ) \
    #  && { echo "notified server"; exit 0; } \
    #  || { echo "ns:$1 failed tx"; exit 1; }
    #fi
    ;;
  --t) ## testmode [<off>]
    [ "$2" == "off" ] \
    && rm -f /etc/default/${0##*/}.test \
    || touch /etc/default/${0##*/}.test
    exit 0
    ;;
  --) ## confirm executable
    echo ${0##*/} >/dev/stderr
    exit 0
    ;;
  -h|?)
    sed -n 's/\(^  --.*\)) ## \(.*\)/\1\r\t\t\2/p' $0
    exit 0
esac
#
# if the following file exists, then set tm
[ -f /etc/default/${0##*/}.test ] && tm=echo || tm=

# process firmware update list url, if we have one
if [ -n "$fwul_url" ]
then
  $WGET -t $WGET_RETRIES $fwul_url -O $FWUL 2>/dev/null \
  && echo "Retrieved firmware-update-list for $remote_version" \
  || exit_error "Error: Could not retrieve \"${FWUL##*/}\"."
fi

# parse the firmware-update-list of md5sums, if we have one
if [ -f $FWUL ]
then
  [ -n "$tm" ] && echo $FWUL: && cat $FWUL
  eval `sed -n "/$BOOTSTRAP_IMG/s/^\(.*\)[, ]\(.*\)/BOOTSTRAP_IMG=\1 BOOTSTRAP_MD5=\2/p" $FWUL`
  eval `sed -n "/$UBOOT_IMG/s/^\(.*\)[, ]\(.*\)/UBOOT_IMG=\1 UBOOT_MD5=\2/p" $FWUL`
  eval `sed -n "/$KERNEL_IMG/s/^\(.*\)[, ]\(.*\)/KERNEL_IMG=\1 KERNEL_MD5=\2/p" $FWUL`
  eval `sed -n "/$ROOTFS_IMG/s/^\(.*\)[, ]\(.*\)/ROOTFS_IMG=\1 ROOTFS_MD5=\2/p" $FWUL`
fi


#
# check this is an embedded architecture before really doing any update
# maybe /proc/partitions or /proc/mtd is also good way to test
#if ! grep -q ARM926 /proc/cpuinfo \
#&& [ -z "$tm" ]
#then
#  exit_error "This script is for embedded Linux only."
#fi

# in testmode, don't do any writes
FW_SETENV=$tm\ $FW_SETENV
NANDWRITE=$tm\ $NANDWRITE
FLASH_ERASE=$tm\ $FLASH_ERASE
if [ -n "$tm" ]
then
  echo "  ...running in testmode!"
fi
#
# the rest of this script handles update operations
#


kernel_x() {
  # report the kernel partition booted from... (pseudo-static)
  $FW_PRINTENV -n bootcmd \
  |grep -q 'nand read 0x22000000 0x[0]*360000 0x280000' && echo 5 || echo 4
}

rootfs_x() {
  # report the (actual) rootfs partition being used...
  cat /proc/cmdline |sed -n 's/.*ubi.mtd=\(.\).*/\1/p'
}

# arg1 is updated-partition a/b to revert
revert_kernel_if_updated() {
  case `$FW_PRINTENV -n updated_kernel 2>/dev/null` in
    b)
      echo "reverting to kernel-a"
      $FW_SETENV bootcmd 'nand read 0x22000000 0x00E0000 0x280000; bootm'
      ;;
    a)
      echo "reverting to kernel-b"
      $FW_SETENV bootcmd 'nand read 0x22000000 0x0360000 0x280000; bootm'
      ;;
  esac
  # clear the updated flag
  $FW_SETENV updated_kernel
}


# arg1 is url/path/file
# arg2 is (included) md5sum
# returns status and size, md5sum, local/remote, url/path/file
check_image()
{
  let rv=0
  if echo $1 |grep -q tp://
  then
    # transfer-protocol required
    # the following works for ftp:// or http://
    sz=$( $WGET --spider $1 2>&1 |sed -n 's/.*SIZE.* \([0-9]*\)/\1/p;s/Length: \([0-9]*\)\ .*/\1/p' )
    md5=$2
    lr=remote
  else
    # assume it's local
    sz=$( F='\([^ ][^ ]*\)\ *'; ls -l $1 2>/dev/null |sed -n "s/^$F$F$F$F$F.*/\5/p" )
    md5=`[ -f $1 ] && md5sum $1 |cut -d' ' -f1`
    lr=local
  fi
  let sz+=0
  [ $sz -gt 0 ] || let rv+=1
  #
  echo $sz $md5 $lr $1 $rv
  return $rv
}

# arg1 is md5 from update
# arg2 is md5 from flash-env
# compare md5sums and prompt if same
compare_flash_image_md5()
{
  a=y
  [ -n "$tm" ] && echo $2 =?= $1
  if [ -n "$2" ] && [ "$2" == "$1" ]
  then
    echo "the image-update and flash are the same"
    read -t10 -n1 -s -p "Update the flash anyway? [y/N ...waiting 5s]" a
    echo -en \\033[1K\\r
  fi
  [ "$a" != "y" ] && return 1 || return 0
}


  # not used currently
  #update_image_proceedure $mtd "bootstrap" $2 $3
# arg1 is label
# arg2 is source
# arg3 is image
update_image_proceedure()
{
  mtd=$2
  echo -en "Updating $1 from $4... "
  $FLASH_ERASE -q /dev/$mtd 0 0
  let et=$2/$NWBPS
  echo -en "writing...${et}s "
  $NANDWRITE -mpq /dev/$mtd < $FIFO &
  if [ "$4" != "local" ]
  then
    $WGET -t $WGET_RETRIES -O $FIFO $5 2>/dev/null \
    || msg="failed to retrieve image update"
  else
    $tm cat $5 >$FIFO 2>/dev/null
  fi
  wait
}


# arg1 is partition
# arg2 is image size
# arg3 is image md5sum
# arg4 is local or remote
# arg5 is image url/path/-name
update_bootstrap_mtd()
{
  [ -n "$tm" ] && echo $@
  [ $2 -gt 0 ] || return
  let et=$2/$NWBPS 
  # set target partition
  mtd=mtd$1
  compare_flash_image_md5 $3 $( $FW_PRINTENV -n md5_bootstrap 2>/dev/null ) || return
  echo -en "Updating bootstrap from $4... "
  $FLASH_ERASE -q /dev/$mtd 0 0
  echo -en "writing...${et}s "
  $NANDWRITE -mpq /dev/$mtd < $FIFO &
  if [ "$4" != "local" ]
  then
    $WGET -t $WGET_RETRIES -O $FIFO $5 2>/dev/null \
    || msg="image update retrieval interrupted"
  else
    $tm cat $5 >$FIFO 2>/dev/null
  fi
  wait
  if [ $? != 0 ]
  then
    exit_error "\nError - $msg"
  fi
  $FW_SETENV md5_bootstrap $3 \
  && echo "OK"
}

# arg1 is partition
# arg2 is image size
# arg3 is image md5sum
# arg4 is local or remote
# arg5 is image url/path/-name
update_bootloader_mtd()
{
  [ -n "$tm" ] && echo $@
  [ $2 -gt 0 ] || return
  let et=$2/$NWBPS 
  # set target partition
  mtd=mtd$1
  compare_flash_image_md5 $3 $( $FW_PRINTENV -n md5_u-boot 2>/dev/null ) || return
  echo -en "Updating bootloader from $4... "
  $FLASH_ERASE -q /dev/$mtd 0 0
  echo -en "writing...${et}s "
  $NANDWRITE -mpq /dev/$mtd < $FIFO &
  if [ "$4" != "local" ]
  then
    $WGET -t $WGET_RETRIES -O $FIFO $5 2>/dev/null \
    || msg="image update retrieval interrupted"
  else
    $tm cat $5 >$FIFO 2>/dev/null
  fi
  wait
  if [ $? != 0 ]
  then
    exit_error "\nError - $msg"
  fi
  $FW_SETENV md5_u-boot $3 \
  && echo "OK"
}

# arg1 is partition
# arg2 is image size
# arg3 is image md5sum
# arg4 is local or remote
# arg5 is image url/path/-name
update_kernel_mtd()
{
  [ -n "$tm" ] && echo $@
  [ $2 -gt 0 ] || return
  let et=$2/$NWBPS 
  # swap current partition to target for update
  case $1 in
    4) mtd=mtd5; ab=b; bootcmd='nand read 0x22000000 0x0360000 0x280000; bootm';;
    5) mtd=mtd4; ab=a; bootcmd='nand read 0x22000000 0x00E0000 0x280000; bootm';;
  esac
  if uf=$( $FW_PRINTENV -n updated_kernel 2>/dev/null ) && [ -z $tm ]
  then
    echo "Previous update detected: kernel-$uf"
    return
  fi
  compare_flash_image_md5 $3 $( $FW_PRINTENV -n md5_kernel-$ab 2>/dev/null ) || return
  echo -en "Updating kernel-$ab from $4... "
  $FLASH_ERASE -q /dev/$mtd 0 0
  echo -en "writing...${et}s "
  $NANDWRITE -mpq /dev/$mtd < $FIFO &
  if [ "$4" != "local" ]
  then
    $WGET -t $WGET_RETRIES -O $FIFO $5 2>/dev/null \
    || msg="image update retrieval interrupted"
  else
    $tm cat $5 >$FIFO 2>/dev/null
  fi
  wait
  if [ $? != 0 ]
  then
    exit_error "\nError - $msg"
  fi
  $FW_SETENV bootcmd $bootcmd
  $FW_SETENV updated_kernel $ab
  $FW_SETENV md5_kernel-$ab $3 \
  && echo "OK"
}

# arg1 is partition
# arg2 is image size
# arg3 is image md5sum
# arg4 is local or remote
# arg5 is image url/path/-name
update_rootfs_mtd()
{
  [ -n "$tm" ] && echo $@
  [ $2 -gt 0 ] || return
  let et=$2/$NWBPS 
  # swap partition to target
  case $1 in
    6) mtd=mtd7; ab=b;;
    7) mtd=mtd6; ab=a;;
  esac
  bootargs=$( $FW_PRINTENV -n bootargs |sed "s/ubi.mtd=./ubi.mtd=${mtd##*mtd}/" )
  if uf=$( $FW_PRINTENV -n updated_rootfs 2>/dev/null ) && [ -z $tm ]
  then
    echo "Previous update detected: rootfs-$uf"
    return
  fi
  compare_flash_image_md5 $3 $( $FW_PRINTENV -n md5_rootfs-$ab 2>/dev/null ) || return
  echo -en "Updating rootfs-$ab from $4... "
  $FLASH_ERASE -q /dev/$mtd 0 0
  echo -en "writing...${et}s "
  $NANDWRITE -mpq /dev/$mtd < $FIFO &
  if [ "$4" != "local" ]
  then
    $WGET -t $WGET_RETRIES -O $FIFO $5 2>/dev/null \
    || msg="image update retrieval interrupted"
  else
    $tm cat $5 >$FIFO 2>/dev/null
  fi
  wait
  if [ $? != 0 ]
  then
    revert_kernel_if_updated
    exit_error "\nError - $msg"
  fi
  $FW_SETENV bootargs $bootargs
  $FW_SETENV updated_rootfs $ab
  $FW_SETENV md5_rootfs-$ab $3 \
  && echo "OK"
}



#
# Check and update each of the platform partitions in order:
# bootstrap-loader, uboot-bootloader, kernel, rootfs
# The image source is evaluated to ensure it's really there.
# The kernel-a/b and rootfs-a/b partitions each get swapped.
# If a rootfs update fails, then revert an updated kernel.
#
mkfifo $FIFO

echo Checking Bootstrap Loader ...
if params=$( check_image $BOOTSTRAP_IMG $BOOTSTRAP_MD5 )
then
  update_bootstrap_mtd 0 $params
else
  echo "update n/a"
fi

echo Checking U-Boot Loader ...
if params=$( check_image $UBOOT_IMG $UBOOT_MD5 )
then
  update_bootloader_mtd 1 $params
else
  echo "update n/a"
fi

echo Checking Linux Kernel ...
if params=$( check_image $KERNEL_IMG $KERNEL_MD5 )
then
  update_kernel_mtd `kernel_x` $params
else
  echo "update n/a"
fi

echo Checking Root Filesystem ...
if params=$( check_image $ROOTFS_IMG $ROOTFS_MD5 )
then
  update_rootfs_mtd `rootfs_x` $params
else
  echo "update n/a"
fi

exit_okay "Update complete."

